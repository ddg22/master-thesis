\chapter{Implementation}
\label{chap:implementation}
This chapter describes the practical implementation of the \acrlong{ew} system, building upon the designs introduced in the previous chapters. While \cref{chap:onchainDesign} and \cref{chap:offchainDesign} focus on the system's architecture and the rationale behind key design decisions, this chapter highlights the concrete tools, technologies, and development processes used to bring the system to life.

Key implementations aspects include the use of account abstraction for users account, the integration of off-chain and on-chain components and the introduction of an access control system that empowers students to manage who can access their data. Special attention is given to the coordination between the academic records system and the decentralized storage layer. 

\section{Development Environment}
This section outlines the tools and technologies used to author, compile, and test \acrlong{ew} system.

The primary code editor is Visual Studio Code, chosen for its lightweight footprint and extensive ecosystem of extensions. To support Solidity development, we installed the Nomic Foundation's Solidity extension, which provides syntax highlighting, inline error detection, and code completion directly within the editor, thereby accelerating development and debugging.

To compile contracts and simulate a local blockchain, we utilize Hardhat\footnote{\url{https://hardhat.org/}}. Our configuration specifies:
\begin{itemize}
    \item \textbf{Solidity compiler version}: 0.8.28 (the latest fully supported by Hardhat at the time of writing)\footnote{Versions 0.8.29 and 0.8.30 were not yet fully supported.}
    \item \textbf{EVM version}: Cancun
    \item \textbf{Optimizer settings}: Enabled with 1000 runs to reduce bytecode size and keep contracts (e.g., \texttt{Student}, \texttt{EntryPoint}) below the 24576-byte limit.
    \item \textbf{Preconfigured account}: A single funded \acrshort{eoa} serves as deployer, funder for student and university wallets, and system administrator. Its private key is fixed to ensure deterministic contract addresses, as these are derived from the deployer’s key and the number of contracts deployed by the account (nonce).
\end{itemize}
The complete Hardhat configuration can be found in \cref{chap:hardhatConf}.

For blockchain interaction in off-chain code, we rely on two core libraries:
\begin{itemize}
\item \textbf{ethers}: Provides providers for network connectivity, cryptographic utilities (e.g., PBKDF2), and the \texttt{Wallet} class for \acrshort{eoa} key management and transaction signing.
\item \textbf{TypeChain}: A Hardhat plug-in that generates TypeScript bindings from contract \acrfull{abi}, enabling contracts to be imported and used as strongly typed classes.
\end{itemize}

Finally, our smart contracts leverage external libraries to streamline common patterns:
\begin{itemize}
\item \textbf{OpenZeppelin Contracts}: Supplies contract implementations of access control and other standard modules.
\item \textbf{AccountAbstraction}: Provides the EntryPoint contract and abstract contracts required for ERC-4337 account abstraction.
\end{itemize}

\section{Account Abstraction and On-Chain Integration in Off-Chain Components}
As described in \cref{ssec:accountAbstraction}, account abstraction redefines on-chain interactions within the \acrlong{eth} network. Whereas traditions transactions were bound to \acrlong{eoa}, the introduction of UserOperations enables \acrlong{sca} to initiate and execute transactions directly on-chain. This paradigm shift also alters how off-chain components interact with and invoke on-chain logic.

In \cref{ssec:extBlockchainInteraction}, we identified three primary modalities for invoking smart contract functionality:
\begin{enumerate}
    \item Direct view function calls
    \item View function calls via a \acrlong{sca}
    \item Gas-consuming transactions via a \acrlong{sca}
\end{enumerate}
The following subsections detail the code patterns used to implement each modality.

\subsection{Direct View Function Calls}
To perform a direct call to the view function shown in \cref{lst:directFuncCall}, the system first initializes an ethers provider. It then uses the StudentsRegister\_\_factory class generated by TypeChain to create a StudentRegister instance connected to the on-chain contract via the \textit{connect} method, which accepts the contract address and provider as arguments. The instance exposes all public functions, variables, and types defined in the Solidity contract. 
Because the target function is permissioned, the student's \acrshort{eoa} must be connected as the transaction sender. This is achieved by invoking the factory's \textit{connect} method again, this time passing a \textit{Wallet}, instantiated with the student's private key and the same provider. The view function is then called as a standard method on the resulting object. The return value is automatically typed according to the contract's Solidity definition and, in this case, is a string.

\lstinputlisting[
    caption={Direct call to a smart contract view function},
    label=lst:directFuncCall,
    language=TypeScript
]{listings/directFunctionCall.ts}

\subsection{View Function Calls via a Smart Contract Account}
\label{ssec:viewFunctionCalls}
View functions calls via a \acrshort{sca} exploit the \textit{executeViewCall} method defined in the SmartAccount abstract contract (see \cref{lst:executeViewCall}). This method, which can be only invoked by the \acrshort{sca} owner, accepts two arguments: the address of the target contract and encoded function name and parameters. By using it, \acrshort{sca}s can perform read-only operations without using submitting gas-consuming transactions. 
\lstinputlisting[
    caption={\textit{executeViewCall} method in the \textit{SmartAccount} abstract contract.},
    label=lst:executeViewCall,
    language=Solidity
]{listings/executeViewCall.sol}

To invoke this method from TypeScript, the steps illustrated in \cref{lst:executeViewCallTS} must be followed:
\begin{enumerate}
    \item \textbf{Calldata encoding}: The target function’s selector and parameters must be encoded into a hexadecimal string. We use the \textit{BaseContract} class from \textit{ethers} to generate this encoding in a generic way, independent of the specific contract interface.
    \item \textbf{Account connection and method invocation}: Instantiate a \textit{SmartAccount} contract object connected with the owner’s \acrshort{eoa} wallet (e.g., the university’s \acrshort{eoa}). Then, invoke the \textit{executeViewCall} method on thhis connected \acrshort{sca} instance, passing the target contracts address along with the encoded calldata.
    \item \textbf{Result decoding}: The call returns an encoded hexadecimal string. We decode it back into expected return type using \textit{ethers} utilities.
\end{enumerate}
\lstinputlisting[
    caption={TypeScript code invoking \textit{executeViewCall} on a \textit{SmartAccount} instance.},
    label=lst:executeViewCallTS,
    language=TypeScript
]{listings/executeViewCall.ts}

\subsection{Gas-Consuming Transactions via Smart Contract Account}
To execute state-changing operations, such as granting or revoking permissions, our off-chain components fully leverage the ERC-4337 account abstraction protocol. On the smart-contract side, the \textit{BaseAccount} abstract contract (see \cref{chap:baseAccount}) provides two core methods:
\begin{enumerate}
    \item \textbf{execute}: Accepts a target address (either an \acrshort{eoa} or another smart contract), a value (\acrshort{eth} to transfer) and encoded calldata, then performs a single transaction.
    \item \textbf{executeBatch}: Accepts an array of such triples (address, value, calldata) and executes them automatically in a single transaction.
\end{enumerate}

Both methods incur in gas costs, in contrast to the read-only \textit{executeViewCall} from \cref{ssec:viewFunctionCalls}.

Account abstraction security is enforced by the \textit{validateUserOp} function within BaseAccount, invoked by the EntryPoint contratc before execution. Within \textit{validateUserOp}, our SmartAccount calls its own \textit{\_validateSignature} helper (see \cref{lst:validateSignature}),  which in our case simply verifies that the UserOperation’s signer matches the account owner.
\lstinputlisting[
    caption={TypeScript code invoking \textit{executeViewCall} on a \textit{SmartAccount} instance.},
    label=lst:validateSignature,
    language=Solidity
]{listings/validateSignature.sol}

On the client side, we encapsulate UserOperation handling in an \textit{AccountAbstraction} TypeScript class (see \cref{chap:accountAbstraction}). Because no public bundlers are available in our local testnet, we must format and submit operations directly to the EntryPoint contract as \textit{PackedUserOperation} objects. The workflow is as follows:
\begin{enumerate}
    \item \textbf{Create the UserOperation}: Populate fields such as sender address, target contract address, value, calldata, gas and fee parameters, and paymaster details (see \cref{ssec:accountAbstraction}).
    \item \textbf{Pack the UserOperation}: pack and encode some UserOperation fields, such as the gas consumption ones.
    \item \textbf{Sign the UserOperation}: Sign the packed payload with the sender's \acrshort{eoa} using \textit{ethers} utilities, incorporating some network information and operation format.
    \item \textbf{Send the UserOperation}: Submit the signed operation via the \textit{EntryPoint.handleOps} method. Because this submission itself is a transaction, the \acrshort{cli} must pre-fund both university and student \acrlong{eoa}s on the testnet. 
    \item \textbf{Verify the result}: After execution, inspect the returned execution trace stack for any exception logs emitted by the UserOperation. An absence of such errors confirms successful execution.
\end{enumerate}

The primary limitation of our implementation lies in gas consumption estimation. In our AccountAbstraction class, all gas and fee-related parameters are hardcoded. Since the system operates in a controlled testing environment with dedicated paymaster and user accounts pre-funded with large balances, we configured these limits conservatively, setting them to high values to avoid transaction failures due to out-of-gas errors.
We chose not to implement a more advanced gas estimation mechanism, as it would introduce unnecessary complexity in the context of a local setup. In a real-world deployment, this concern is mitigated by bundlers, which either expose utilities for gas estimation or handle it internally. As a result, the interaction with UserOperations becomes seamless for the end user and developers alike.

\section{Access Control System}